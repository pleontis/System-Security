Leontis Panagiotis AM: 2018030099

$ gcc --version

gcc (Ubuntu 9.3.0-17ubuntu1~20.04)

Δεν κατάφερα να υλοποιήσω σωστά την συνάρτηση foopen64() γι αυτο η υλοποίηση μου δεν είναι ακριβώς αυτό που ζητάτε. Όλα τα υπόλοιπα 
λειτουργούν κανονικά.

Παράδειγμα για εντολές που θα κάνουν  encrypt το file1.txt και μετα ελέγχουμε αν δημιουργήθηκαν πάνω από 2 αρχεία
και έπειτα εκτυπώνουμε και ποια αρχεία κρυπτογραφήθηκαν απο το ransomware
make clean
make all
./ransomware file1.txt
Στο μενού που εκτυπώνεται επιλέγουμε εντολή 1
./acmonitor -v 2
./acmonitor -e

=====================================================ransomware.sh===================================================== 

	Εάν επιθυμούμε λειτουργία encryption τότε πληκτρολογούμε
	./ransomware.sh file1.txt file2.txt (όσα ονόματα αρχείων θέλουμε)
	και μετα στο μενού πληκτρολογούμε 1

	Εάν επιθυμούμε λειτουργία Create big volume of files τότε πληκτρολογούμε
	./ransomware.sh <directory> (e.x /home/$USER/Desktop) και τον αριθμό των αρχείων (e.x 5)
	./ransomware.sh /home/$USER/Desktop 5
	και μετα στο μενού πληκτρολογούμε 2

Δεν υπάρχει έλεγχος για το αν έχουν δωθεί κατάλληλα ορίσματα

Επιλογή 1 (encryption): Για κάθε ονομα αρχείου που δόθηκε ως όρισμα ελέγχεται αν υπάρχει και γράφεται ο κατάλληλος
κώδικας μέσα στο test_aclog.c έπειτα φορτώνουμε την βιβλιοθήκη logger.so χρησιμοποιώντας το κώδικα που υπήρχε στο Makefile
της προηγούμενης εργασίας. Γίνεται η κρυπτογράφιση και αφαιρείται το αρχικό αρχείο. Δίνεται και δυνατότητα για αποκρυπτογράφιση.

Επιλογή 2 (Create a big volume of files): Σε μια for loop χρησιμοποιοείται το πρώτο όρισμα για τη δημιουργία ενός αρχείου στο συγκεκριμένο directory γράφοντας τον αντίστοιχο κώδικα στο test_aclog.c. Φορτώνουμε την βιλιοθήκη και εκτελούμε το εκτελέσιμο αρχείο.
Η fopen δεν μπορεί να φτιάξει directory επομένως το όρισμα πρέπει να είναι ένα υπάρχον directory.


=====================================================acmonitor.c===================================================== 

	Προστέθηκαν οι 2 επιλογές -v <number> και -e 

-v <number> H file_creation_check() διαβάζει το file_logging.log γραμμή γραμμή και υπολογίζεται η διαφορά της ώρας που δημιουργήθηκε το κάθε αρχείο (Acces type 0) 
με την τωρινή ώρα. Εάν η διαφορά είναι μικρότερη από 20 λεπτα και η ημερομηνίες ταυτίζονται τότε αυξάνουμε το counter κατα 1. Τέλος εάν ο counter είναι μεγαλύτερος από το όρισμα number ενημερώνουμε το χρήστη ότι δημιουργήθηκαν περισσότερα από number αρχεία. Αντίσοιχα για το αν counter < number ενημερώνουμε ότι δημιουργήθηκαν λιγότερα.

-e Η print_ransomware_encrypted() διαβαζει το file_logging.log γραμμή γραμμή και εκει που γράφεται το path αποθηκεύεται το path του αρχείου. Εάν έχουμε acces type 0
(δημιουργία αρχείου) τοτε χωρίζουμε το path του αρχείου με το token "." με την split_array(). Εαν το τελευταιο μέρος είναι .encrypt σημαίνει ότι το αρχείο αυτό
κωδικοποιήθηκε από το ransomware.sh. Αυξάνεται κατά 1 ο μετρητής και εκτυπώνεται το path του.

split_array() Συνάρτηση που παίρνει ως όρισμα ένα pointer char που δείχνει στο string που θέλουμε να διασπάσουμε, το token και έναν pointer που θα περιέχει τα κομμάτια που
διασπάστηκαν. (e.x με token "/" και string /home/user/Desktop το split_array θα το χωρίσει σε home user Desktop.
